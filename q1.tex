
\section{What MVC ?}

Software decays at a faster rate than most other engineering artifacts - the circumstances under which a piece of software must operate can evolve at a rapid pace and render it obsolete. Consequently, software engineering grew largely out of the need for software that could be easier to maintain, debug, and extend as the environment in which it operated evolved, grew, and adapted to new technological, social, and economic mores. An important notion to arise from this need is that software should be developed such that its components exhibit high cohesion and low coupling. If our components exhibit high coupling, then a modifying some component A will directly affect all components that depend on component A.

However, writing software that is decoupled and cohesive is not a trivial task. In light of this fact, software engineers and software developers need methodologies and software architectures that they can leverage to make their code as easy to maintain and as decoupled as possible  while facilitating responsible code-reuse, flexibility, and low code complexity. One of the post popular software architectures used in trying to achieve this is the Model-View-Controller (henceforth referred to as MVC) software architecture.

Let us now analyze MVC along its three facets - Model, View, and Controller in that order

\section{Model}

A web application that displays agricultural data to users. An application is a warehouse that monitors the current stock. Both of these applications share an important feature - there is some underlying data model that we want to operate upon in some manner in accord with constraints and  domain logic. 

Abstracting over the underlying data model and its domain logic that is to be used by an application is the responsibility of the \textbf{Model}

In OOD, it is not uncommon for elements of data model or domain to represented as Objects that either encapsulate the data directly, or act as an intermediary between the software and the database system using an ORM.
\section{View}

Our two example applications above also share other important features - they both need some means of allowing users to view data and to request operations of the data (such as inserting records, finding averages, ect...). 

This is activity of presenting data to the user is the responsibility of the \textbf{View}. 

For example, in our web application, our view would comprise our client side markup - our html and css. Similarly, for our warehousing application, our view would be the display component to our UI that the user directly interacts with.

\section{Controller}

In order for our application to be useful to users, there needs to be some mechanism for the Model and the View to interact with one another. However, due to the loose coupling we maintain between them, they don't "speak the same language". Consequently, we need an intermediary that can translate between the two. This task falls on the shoulders of the \textbf{Controller}.


For example, in our web application, our controller would be responsible for handling events in our html pages to request and consume services of the Model in order pass the data off to the View for display to the user.

\section{Diagramtic Summary}

\begin{center}

\begin{tikzpicture}[node distance=2cm]

\node (c1) [component] {View};

\node (c2) [component, right of=c1, xshift=5cm] {Controller};

\node (c3) [component, below of=c2, yshift=-3cm] {Model};

\draw [arrow] (c1) -- node[anchor=east] {} (c2);
\draw [arrow] (c2) -- (c3);
\draw [arrow] (c3) -- (c2);
\draw [arrow] (c2) -- (c1);


\end{tikzpicture}


\end{center}





